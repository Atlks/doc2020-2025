Atitit 常用的登录认证法




用户名密码方式、2、指纹打卡机、3、基于证书验证方法。。系统验证用户身份合法，用

 HTTP 使用的认证方式; BASIC 认证（基本认证）; DIGEST 认证（摘要认证）;
 
HTTP Basic Authentication
将认证的信息填写到请求头，参考博客文章

basic认证是另一个常用的认证方式，与表单认证不同的是，basic认证常用于无状态客户端的验证，比如HttpInvoker或者Web Service的认证，这种场景的特点是客户端每次访问应用时，都在请求头部携带认证信息，一般就是用户名和密码，因为basic认证会传递明文，所以最好使用https传输数据。

：服务器端向客户端返回 401（Unauthorized，未被授权的） 状态码，并在  WWW-Authenticate 首部提供如何进行验证的信息，其中至少包含有一种质询方式。之后有意向证明自己身份的客户端可以在新的请求中添加 Authorization 首部字段进行验证，字段值为身份验证凭证信息。通常客户端会弹出一个密码框让用户填写，然后发送包含有恰当的 Authorization  首部的请求。
验证方案
通用 HTTP 身份验证框架可以被多个验证方案使用。不同的验证方案会在安全强度以及在客户端或服务器端软件中可获得的难易程度上有所不同。
最常见的验证方案是“基本验证方案”（"Basic"），该方案会在下面进行详细阐述。 IANA 维护了一系列的验证方案，除此之外还有其他类型的验证方案由虚拟主机服务提供，例如 Amazon AWS 。常见的验证方案包括：
Basic (查看 RFC 7617, base64编码凭证. 详情请参阅下文.),
Bearer (查看 RFC 6750, bearer 令牌通过OAuth 2.0保护资源),
Digest (查看 RFC 7616, 只有 md5 散列 在Firefox中支持, 查看 bug 472823 用于SHA加密支持),
HOBA (查看 RFC 7486 (草案), HTTP Origin-Bound 认证, 基于数字签名),
Mutual (查看 draft-ietf-httpauth-mutual),

AWS4-HMAC-SHA256 (查看 AWS docs).




Digest模式
        HTTP协议规范的另一种认证模式是Digest模式，在HTTP1.1 时被提出来，它主要是为了解决Basic模式安全问题，用于替代原来的Basic认证模式， Digest认证也是采用challenge/response认证模式，基本的认证流程比较类似，整个过程如下：
①浏览器发送http报文请求一个受保护的资源。
②服务端的web容器将http响应报文的响应码设为401 ，响应头部比Basic模式复杂，WWW-Authenticate: Digest realm=”myTomcat”,qop="auth",nonce="xxxxxxxxxxx",opaque="xxxxxxxx"  。其中qop的auth表示鉴别方式；nonce 是随机字符串

表单验证Form模式  FormBase 认证（基于表单认证）表单验证 
三、Form Based Authentication 表单认证
表单提交认证：认证信息作为请求参数，类似于Http基本认证

        上面介绍的两种模式都属于HTTP协议规范范畴，由于它的规范使得很多东西无法自定义，例如登录窗口、错误展示页面。所以需要另外一种模式提供更加灵活的认证，也就是基于Form 的认证模式，各种语言体系的web容器都可以实现各自的Form模式，这里只介绍 java体系的Form认证模式：
        Form模式的认证流程如下：
①浏览器发送http报文请求一个受保护的资源。
②服务端的web容器判断此uri为受保护资源，于是将请求重定向到自定义的登陆页面上，例如 login.html页面，可以自定义登陆页面的样式，但要遵守的约定是表单的action必须以j_security_check结尾，即<form action='xxxxxx/j_security_check' method='POST'>。用户名和密码输入框元素的name必须为'j_username' 和'j_password'。
③浏览器展示自定义的登陆页面让用户输入用户名和密码，然后提交表单。
④服务端web容器获取表单的用户名和密码，匹配此用户名与密码是否正确，是否有相应资源的权限，如果认证成功则返回相关资源，否则再执行②，重新进行认证。
⑤后面在同个会话期间的访问都不用再进行认证，因为认证的结果已经保存在服务端的session里面。     
        Form模式跳出了HTTP规范提供了自定义的更加灵活的认证模式，由于每种语言都可以自己定义实现自己的Form 模式，所以它没有一个通用的标准，而且它也存在密码明文传输安全问题。

OAuth 认证


Web票据模式验证
Token验证 
Cookie-Session 认证

Cookie-Session 改造版
由于传统的 Cookie-Session 认证存在诸多问题，可以把上面的方案改造一下。改动的地方如下：
不用 cookie 做客户端存储，改用其他方式，web 下使用 local storage，APP 中使用客户端数据库，这样就实现了跨域，并且避免了 CSRF ;
服务端也不存 Session 了，把 Session 信息拿出来存到 Redis 等内存数据库中，这样即提高了速度，又避免了 Session 同步问题；
经过改造之后变成了如下的认证过程：
用户输入用户名、密码或者用短信验证码方式登录系统；
服务端经过验证，将认证信息构造好的数据结构存储到 Redis 中，并将 key 值返回给客户端；
客户端拿到返回的 key，存储到 local storage 或本地数据库；
下次客户端再次请求，把 key 值附加到 header 或者 请求体中；
服务端根据获取的 key，到 Redis 中获取认证信息；
基于JWT的Token认证
上面的方案虽然经过了改版，但还是需要客户端和服务器端维持一个状态信息，比如用 cookie 换 session ,或者用 key 换 Redis 的 value 信息，基于 JWT 的 Token 认证方案可以省去这个过程。
JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用JWT在用户和服务器之间传递安全可靠的信息




说一说几种常用的登录认证方式，你用的哪种 - 风的姿态 - 博客园.html

  SSL模式
        SSL模式是基于SSL通信的一种认证模式，它的大体流程是这样的：客户端与服务器之间通过 SSL协议建立起SSL通道，这个过程比较复杂，涉及到客户端服务端证书互相交互验证，协商通信密钥等过程，细节可以前往SSL 章节阅读。完成整个SSL通道建立后才是认证的核心步骤，如下图，
 

①首先获取客户端证书文件，这个由于在SSL协议期间已经发送到服务端，所以可以直接从内存中获取，然后解析证书文件得到证书标识。
②通过这个证书标识去存放用户信息的地方查找出对应客户端证书用户的相关信息。
③检查此用户是否有相关资源的权限，如果验证通过则返回请求相关资源。  
        SSL模式也提供了高安全认证，它只对颁发的客户端证书个体信任，可用于服务端与服务端之间的通信，也可以用在浏览器与web服务器之间通信，这时必须使用 https协议，因为它必须走SSL协议通道才能完成认证流程。    
        本文介绍了五种常见的安全认证机制，他们各自有各自的优缺点，在实际使用中根据具体的场景选择不同的认证机制。


Other
生物数据验证
3、基于证书验证方法。

Tool
Nginx shiro spirng-secury
Ref
Atitit 安全领域  身份验证技术总结 权限设计 访问控制ac技术 acl rbac abac模式
说一说几种常用的登录认证方式，你用的哪种


前端的登录验证是怎么实现的？掌握这4种方法，再也不担心鉴权了 – 柚柚科技.html
