
atitit 编程语言之道attilax著.docx



1. 编程语言常见概念与理论	9
1.1. solid原则	9
1.2. 变量6属性	9
1.3. 三大流程	9
1.4. 异常控制流程	9
1.5. 流程图（Flow Chart	9
1.6. 多分支结构	9
1.7. 表达式（中缀前缀表达式	9
1.8. 运算符	9
1.9. 数据类型	9
1.10. Lambda 表达式	9
1.11. 方法引用	10
1.12. 生命周期	10
1.13. Cohesion	10
1.14. 耦合Coupling	10
1.15. 过程	10
1.16. 函数	10
1.17. 返回值	10
1.18. 循环(loop),	10
1.19. 递归(recursion),	10
1.20. 遍历(traversal),	10
1.21. 迭代(iterate).	11
1.22. 泛型	11
1.23. 环境变量	11
1.24. s-exp	11
1.25. 类型系统	11
2. 编程语言种类 and趋势 逻辑式语言..函数式语言...命令式语言	11
3. 语言实现	13
3.1. 词法分析	13
3.2. fsm状态机	13
3.3. 正则表达式	13
3.4. 词性标注	13
3.5. 语法分析	13
3.6. ast	13
3.7. 语义分析	13
3.8. 内部DSL实现模式	13
3.9. 外部DSL	13
3.10. 生成AST	13
3.11. BNF	14
3.12. 正则表达式表的词法分析器	14
3.13. 递归下降法语法解析器	14
3.14. 解释器	14
3.15. 表达式生成器	14
3.16. 嵌套函数	14
3.17. 方法级联	14
3.18. 状态机fsm	14
4. 函数式理论 章节	15
4.1. lambda	15
4.2. stream	15
4.3. fluce接口	15
4.4. 连锁接口	15
4.5. pipe	15
4.6. map & reduce	15
4.7. pipeline	15
4.8. 高阶函数	15
4.9. 闭包	15
4.10. 表达式特化	15
4.11. 表达式合成	16
4.12. 外循环	16
4.13. 内循环	16
4.14. 惰性求值	16
5. 类与对象实现 章节	18
5.1. class模板	18
5.2. dock type	18
5.3. is-a has-a	18
5.4. mix in	18
5.5. oo三大特性	18
5.6. solid原则	18
5.7. 抽象方法	18
5.8. 抽象类和	18
5.9. 单根继承	18
5.10. 单例	18
5.11. 动态绑定（dynamic binding	18
5.12. 动态对象	19
5.13. 对象持久性（object persistence	19
6. 章节	21
7. dsl 章节	21
8. io输入输出 章节	21
8.1. 文件的io	21
8.2. 网络的io	21
8.3. rest接口	21
8.4. http	21
8.5. socket	21
8.6. console重写	21
8.7. 异常打印string	21
8.8. 字符流	21
8.9. 字节流	22
8.10. io体系	22
8.11. 图片的io	22
8.12. 二进制io	22
8.13. 文本io	22
8.14. 字符编码	22
8.15. request	22
9. 并发与锁机制 章节	23
9.1. Volatile  内存屏障	23
9.2. cas	23
9.3. atomic	23
9.4. 同步关键字	23
9.5. ReentrantLock	23
9.6. 自旋锁	23
9.7. 信号量	23
9.8. 互斥锁Mutex	23
9.9. 线程死锁	23
9.10. 线程死锁kill	23
9.11. 异步	24
9.12. 线程池	24
9.13. task模型	24
9.14. futuretask模式	24
9.15. 毒丸	24
9.16. threadlocalhost	24
10. api设计 章节	25
10.1. 方法连	25
10.2. jquery	25
10.3. guava	25
10.4. option	25
10.5. 面向接口编程	25
10.6. 工厂方法优于构造函数	25
10.7. polyfill	25
10.8. dsl命名法	25
10.9. 参考知名api	25
10.10. 归一化	26
10.11. 命名参数	26
11. gc资源释放 章节	27
11.1. 分代	27
11.2. 基于时间	27
11.3. 引用计数	27
11.4. amr	27
11.5. watchdog	27
11.6. 	27
12. 调试技术 章节	27
12.1. log调试	27
12.2. ide调试	27
12.3. 监测工具	27
12.4. sdk调试支持api	27
13. 反射 章节	28
14. 异常处理 章节	29
14.1. 异常捕获策略	29
14.2. 处理策略	29
14.3. 抛出策略	29
14.4. 跨语言异常	29
14.5. 异常转换	29
14.6. 异常序列化	29
14.7. Atitit 异常and 流程控制	29
14.8. 返回码模式	29
14.9. 终止模式  vs 恢复模式	30
14.10. 异常机制的设计原理	30
14.11. 类库实现异常catch	30
14.12. Check ex vs unchk ex	30
14.13. 业务异常	30
14.14. 异常分类	30
14.15. 重新抛出异常和异常链	30
14.16. 全局异常捕获	31
15. 事件机制 章节	31
15.1. event对象	32
15.2. 事件目标（event target	32
15.3. 事件传播（event propagation	32
15.4. event handler	32
15.5. 事件分发器	32
15.6. 事件委托	32
15.7. 事件代理	32
15.8. 事件循环	32
15.9. 事件驱动 vs 轮询机制	32
15.10. 事件队列	33
15.11. vs消息机制	33
15.12. 事件注册	33
15.13. 事件调用	33
15.14. 事件对象模型	33
15.15. 事件冒泡	33
15.16. 事件捕获	33
15.17. 事件底层 中断原理	33
16. 重构 章节	34
17. 章节	34
18. 开发规范 章节	34
19. 序列化 章节	34
19.1. xml序列化	35
19.2. php hash序列化	35
19.3. json序列化	35
19.4. 二进制序列化	35
19.5. 循环引用解决	35
19.6. base64	35
19.7. bin2txt	35
20. ioc 章节	35
21. 性能提升 章节	35
22. gui 章节	36
22.1. gui原理	36
22.2. 界面引擎	36
22.3. 游戏引擎	36
22.4. 布局引擎	36
22.5. 控件系统	36
22.6. 复合控件	36
22.7. pagging翻页控件	36
22.8. css框架	36
22.9. 前端ui框架	36
22.10. css3	37
22.11. 动画	37
22.12. canvas	37
22.13. 音视频	37
23. other 章节	37
24. mvc 章节	37
25. ide 章节	37
26. exop互操作接口 章节	37
27. 常用协议 章节	37
28. 常用web服务器 章节	38
29. 代码管理与同步 章节	38
30. 安全与加密 章节	38
30.1. rsa	38
30.2. 证书	38
30.3. md5	38
30.4. aes	38
30.5. 3des	38
30.6. 注入	38
30.7. crsf	38
30.8. xss	38
31. 架构知识 章节	39
32. 文字处理 章节	39
32.1. 汉字处理	39
32.2. 正则表达式	39
32.3. auth	39
32.4. 全文检索	39
32.5. tie树	39
32.6. 规则查询	39
32.7. 参见图像处理知识图谱	39
33. 图像处理 章节	40
34. uml 章节	40
35. web体系 章节	40
36. 简单的图像处理 章节	40
37. vm 章节	40
38. api标准化 章节	41
38.1. 核心core标准化	41
38.2. 文本处理	41
38.3. 网络处理	41
38.4. 图像处理	41
38.5. 数据库处理	41
38.6. 进程处理	41
38.7. 鼠标键盘管理	41
38.8. 时间处理	41
38.9. 数字处理	41
38.10. 容器	42
39. 常用算法 章节	42
40. 软件工程 章节	42
41. 设计模式 章节	42
42. 标准化 章节	42
42.1. ecma标准	43
42.2. iso标准	43
42.3. apache fund	43
42.4. jcp jsr	43
42.5. gbk	43
42.6. rfc	43
42.7. w3c	43
42.8. ansi	43
42.9. omg	43
42.10. BCP，即Best Current Practice	43
43. 字符编码 章节	44
43.1. gbk	44
43.2. utf8	44
43.3. unicode	44
43.4. 大头端小头	44
43.5. ansi	44
43.6. ascii	44
43.7. utf bom	44
43.8. bigend	44
43.9. littleend	44
43.10. cjk	44
43.11. charset	45
43.12. base64	45
43.13. mime	45
44. bug管理 章节	45
45. 编程原则准则 章节	46
45.1. S.O.L.I.D原则(oo fp) 3	46
45.2. 3.1. Single Responsibility Principle (SRP)–职责单一原则 3	46
45.3. 3.2. Open/Closed Principle (OCP)–开闭原则 3	46
45.4. 3.3. Liskov substitution principle (LSP)–里氏代换原则 3	46
45.5. 3.4. Interface Segregation Principle (ISP)–接口隔离原则 3	46
45.6. 3.5. Dependency Inversion Principle(DIP)–依赖倒置原则 3	47
45.7. 4. Dky法则 dry kiss yagni 3	47
45.8. 5. Other原则 4	47
45.9. 5.1. 可读性优先原则 4	47
45.10. 5.2. 拥抱变化原则  扩展性 4	47
45.11. 5.3.  ：迪米特法则最少知识原则”（Principle of Least Knowledge） 4	47
45.12. 5.4. 迪米特法则（Law?ofDemeter,?LOD） 4	48
45.13. 5.5. Don’t Repeat Yourself(DRY) 4	48
45.14. 5.6. Keep It Simple, Stupid (KISS) 4	48
45.15. 5.7. Program to an interface, not an implementation4	48
45.16. 5.8. You Ain’t Gonna Need It(YAGNI) 4	48
45.17. 5.9. 最小惊讶原则 遵守标准约定注释说什么代码就做什么 5	48
45.18. 5.10. 最小化耦合原则与最大内聚 5	49
45.19. 5.11. 隐藏实现细节原则 5	49
45.20. 5.12. 避免过早优化原则 5	49
45.21. 5.13. 得墨忒耳定律 5	49
45.22. 5.14. Common Closure Principle（CCP）–共同封闭原则 5	49
45.23. 5.15. Common Reuse Principle (CRP)–共同重用原则 5	49
45.24. 5.16. Hollywood Principle–好莱坞原则 5	50
45.25. 5.17. High Cohesion & Low/Loose coupling & –高内聚，低耦合6	50
45.26. 5.18. Convention over Configuration（CoC）–惯例优于配置原则 惯例优先原则6	50
45.27. 5.19. Acyclic Dependencies Principle (ADP)–无环依赖原则 6	50
45.28. 5.20. Postel's law伯斯塔尔法则  后向兼容性设计 6	51
45.29. 5.21. 软件，就像所有技术一样，具有天然的政治性。代码必然会反映作者的选择、偏见和期望。 6	51
45.30. 5.22. 首先为人类设计，其次为机器设计。 6	51
45.31. 5.23. 抽象原则 6	51
45.32. 6. 《编程法则》二十一条 6	51
46. datastruts数据结构 章节	52
46.1. map	52
46.2. list	52
46.3. 元祖	52
46.4. turl	52
46.5. meta、	52
46.6. dic	52
46.7. hashtable	52
46.8. hash	52
46.9. set	52
46.10. array	52
46.11. graph	53
46.12. linklist	53
46.13. tree	53
46.14. collect、	53
46.15. queuo	53
46.16. stack	53
46.17. heap	53
46.18. sort	53
46.19. 查找搜索	53
46.20. 遍历	53
46.21. fifo	53
46.22. datatable	54
47. 源码组织管理 章节	54
48. 标准库 章节	54
48.1. 字符串函数	55
48.2. 数学函数库	55
48.3. 日期运算	55
48.4. 聚合函数	55
48.5. 转换函数	55
48.6. 字符函数	55
48.7. 系统函数	55
48.8. 分析函数（高级统计函数	55
48.9. 条件判断函数	55
48.10. 加密函数	56
48.11. 格式化函数	56



 编程语言常见概念与理论  

编程语言种类 and趋势 逻辑式语言..函数式语言...命令式语言

Atitit.编程语言的主要的种类and趋势 逻辑式语言..函数式语言...命令式语言p825

1. 编程语言的主要的种类 逻辑式语言..函数式语言...命令式语言	1
2. 命令式语言主要组成（运算符与控制结构，if，foreach）	2
3. 函数式语言（全部是函数）	2
4. 逻辑式语言,,不必考虑实现过程而只需考虑定义和结果	2
1. 控制结构将消失,select ,foreach 等...表格将取代select结构	3
5. 第五代语言	3


3.编程语言的主要的种类 逻辑式语言..函数式语言...命令式语言

在FAQ3里说过，世界上有C和LISP两种编程语言，你现在学了C，以后学了C++、Java、.NET 
等等，也仍然只认识了半个世界。LISP和 Haskell构成了另外半个世


4.命令式语言主要组成（运算符与控制结构，if，foreach）
5.函数式语言（全部是函数）

6.逻辑式语言,,不必考虑实现过程而只需考虑定义和结果

例如著名的 prolog。逻辑式语言一般依据成熟的逻辑体系来设计，比如 first-order logic（用于 prolog），因为这样有几点好处：
1）可以进行严密的逻辑推理；
2）可以方便有效地定义 knowledge base，这在专家系统中很重要；
3）开发者不必考虑实现过程而只需考虑定义和结果。这符合专家系统的设计理念。

作者:: 老哇的爪子 Attilax ail，  EMAIL:1466519819@qq.com
转载请注明来源： http://blog.csdn.net/attilax

6.1.控制结构将消失,select ,foreach 等...表格将取代select结构

只需考虑定义和结果,表格将取代select结构...

7.第五代语言 
第五代语言就是自然语言又被称为知识库语言或人工智能语言，人工智能语言主要有LISP、Prolog

人们可能会问，用人工智能语言解决问题与传统的方法有什么区别呢？  
传统方法通常把问题的全部知识以各种的模型表达在固定程序中，问题的求解完全在程序制导下按着预先安排好的步骤一步一步（逐条）执行。解决问题的思路与冯.诺依曼式计算机结构相吻合。当前大型数据库法、数学模型法、统计方法等都是严格结构化的方法。  
对于人工智能技术要解决的问题，往往无法把全部知识都体现在固定的程序中。通常需要建立一个知识库（包含事实和推理规则），程序根据 环境和所给的输入信息以及所要解决的问题来决定自己的行动，所以它是在环境模式的制导下的推理过程。这种方法有极大的灵活性、对话能力、有自我解释能力和 学习能力。这种方法对解决一些条件和目标不大明确或不完备，（即不能很好地形式化，不好描述）的非结构化问题比传统方法好，它通常采用启发式、试探法策略 来解决问题。 


其实，每种编程语言的设计都有 
独到之处，体现了每种语言的精髓，在融汇百家之后积累下来的正是方法论。


语言实现 

函数式理论 章节

 章节
类与对象实现 章节

 章节
dsl 章节
常见类库api=----------------

源码组织管理 章节
 章节
标准库 章节

io输入输出 章节
重构 章节 章节
开发规范 章节
序列化 章节
 章节


ioc 章节
性能提升 章节
 章节
gui 章节

other 章节
mvc 章节
ide 章节
 章节
exop互操作接口 章节
常用协议 章节
 章节
常用web服务器 章节
代码管理与同步 章节
安全与加密 章节

架构知识 章节
 章节
文字处理 章节

图像处理 章节
 章节
uml 章节
web体系 章节
 章节
简单的图像处理 章节
vm 章节
 章节

字符编码 章节

bug管理 章节
 章节

api标准化 章节

常用算法 章节
软件工程 章节
 章节
设计模式 章节
 章节
标准化 章节
 


语言高级机制------------------
并发与锁机制 章节

api设计 章节

gc资源释放 章节

调试技术 章节

反射 章节
 章节
异常处理 章节

事件机制 章节
 章节


编程原则准则 章节

datastruts数据结构 章节





参考资料
atititprgrm tech tree编程语言知识点体系 v7 qb20.xlsx
