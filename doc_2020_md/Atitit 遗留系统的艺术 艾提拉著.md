Atitit 遗留系统的艺术 atl著


《遗留系统重建实战 克里斯·伯查尔(Chris Birchall) 人民邮电出版社》 
【简介_书评_在线阅读】 - 当当 - 正瀚图书专营店.html

正如本书作者所言，大多数开发人员的主要时间都是花费在与现有的软件打交道上，而不是编写全新的应用程序。相信开发人员或多或少都遇到过与遗留系统相关的问题或者困惑，本书致力于帮开发人员回答这些问题，更重要的是，帮开发人员避免把自己当前开发的系统变成别人将来要面临的遗留问题。本书篇幅不长，但涵盖的内容很广，例证丰富，有大量的示例代码（主要使用Java或C#编写），深入浅出地介绍了工作在遗留系统中会遇到的各种问题及应对方法。书中不仅包含技术性的内容—如何选择构建项目的工具，如何自动化构建基础设施，如何决定并进行重构或重写等，也包含非技术性的内容—应该建设什么样的团队文化，如何引入代码评审等活动，如何进行团队知识的传播、改进沟通方式等。
目录

目录

　　

　　



部分　开始

章　了解遗留项目中的挑战 3

1.1 遗留项目的定义 3

1.1.1 遗留项目的特征 4

1.1.2 规则的例外 5

1.2 遗留代码 6

1.2.1 没有测试和无法测试的代码 6

1.2.2 不灵活的代码 8

1.2.3 被技术债务拖累的代码 8

1.3 遗留基础设施 9

1.3.1 开发环境 10

1.3.2 过时的依赖 10

1.3.3 异构环境 11

1.4 遗留文化 12

1.4.1 害怕变化 12

1.4.2 知识仓库 13

1.5 小结 14

第2章 找到起点 15

2.1 克服恐惧和沮丧 15

2.1.1 恐惧 16

2.1.2 沮丧 18

2.2 收集软件的有用数据 19

2.2.1 bug和编码标准违例 20

2.2.2 性能 20

2.2.3 错误计数 23

2.2.4 对常见的任务计时 23

2.2.5 常用文件 24

2.2.6 度量可度量的一切 25

2.3 用FindBugs、PMD和Checkstyle审查代码库 25

2.3.1 在IDE中运行FindBugs 26

2.3.2 处理误报 29

2.3.3 PMD和Checkstyle 32

2.4 用Jenkins进行持续审查 34

2.4.1 持续集成和持续审查 34

2.4.2 安装和设置Jenkins 35

2.4.3 用Jenkins构建和审查代码 36

2.4.4 还能用Jenkins做些什么 37

2.4.5 SonarQube 39

2.5 小结 39

第二部分　通过重构改善代码库

第3章 准备重构 43

3.1 达成团队共识 44

3.1.1 传统主义者 44

3.1.2 反传统主义者 46

3.1.3 一切都在于沟通 47

3.2 获得组织的批准 48

3.2.1 使它变得正式 48

3.2.2 备用计划：神秘的20%计划 49

3.3 选择重构目标 50

3.4 决策时间：重构还是重写 51

3.4.1 不应该重写的情况 52

3.4.2 从头重写的好处 55

3.4.3 重写的必要条件 56

3.4.4 第三种方式：增量重写 57

3.5 小结 58

第4章 重构 59

4.1 有纪律的重构 59

4.1.1 避免麦克白的悲剧 59

4.1.2 把重构和其他的工作分开 60

4.1.3 依靠IDE 61

4.1.4 依靠版本控制系统 64

4.1.5 Mikado方法 65

4.2 常见的遗留代码的特征和重构 66

4.2.1 陈旧代码 66

4.2.2 有毒的测试 68

4.2.3 过多的null 70

4.2.4 不必要的可变状态 73

4.2.5 错综复杂的业务逻辑 74

4.2.6 视图层中的复杂性 79

4.3 测试遗留代码 83

4.3.1 测试不可测试的代码 83

4.3.2 没有单元测试的回归测试 86

4.3.3 让用户为你工作 88

4.4 小结 89

第5章 重搭架构 90

5.1 什么是重搭架构 90

5.2 将单体应用程序分解为模块 92

5.2.1 案例研究—日志管理应用程序 92

5.2.2 定义模块和接口 94

5.2.3 构建脚本和依赖管理 95

5.2.4 分拆模块 96

5.2.5 引入Guice 97

5.2.6 Gradle来了 98

5.2.7 结论 98

5.3 将Web应用程序分发到服务 99

5.3.1 再看一下Orinoco.com 99

5.3.2 选择一个架构 100

5.3.3 继续采用单体架构 101

5.3.4 前后端分离 103

5.3.5 面向服务架构 106

5.3.6 微服务 108

5.3.7 Orinoco.com应该做什么 109

5.4 小结 109

第6章 大规模重写 111

6.1 决定项目范围 112

6.1.1 项目目标是什么 112

6.1.2 记录项目范围 113

6.2 从过去学习 114

6.3 如何处理数据库 115

6.3.1 共享现有数据库 116

6.3.2 创建一个新数据库 119

6.3.3 应用程序间通信 124

6.4 小结 125

第三部分　重构之外——改善项目工作流程与基础设施

第7章 开发环境的自动化 129

7.1 工作的天 129

7.1.1 搭建用户活动仪表盘开发环境 130

7.1.2 出了什么问题 132

7.2 一个好的README文件的价值 134

7.3 用Vagrant和Ansible对开发环境进行自动化 135

7.3.1 Vagrant介绍 135

7.3.2 为用户活动仪表盘项目搭建Vagrant 136

7.3.3 用Ansible进行自动配置 137

7.3.4 添加更多的角色 139

7.3.5 移除对外部数据库的依赖 141

7.3.6 工作的天—再来一次 142

7.4 小结 143

第8章 将自动化扩展到测试环境、预生产环境以及生产环境 144

8.1 自动化基础设施的好处 145

8.1.1 保证环境一致性 145

8.1.2 易于更新软件 145

8.1.3 易于搭建新环境 145

8.1.4 支持追踪配置更改 146

8.2 将自动化扩展到其他环境 146

8.2.1 重构Ansible脚本以处理多种环境 146

8.2.2 为Ansible角色和playbook搭建库 150

8.2.3 让Jenkins负责 152

8.2.4 常见问题 154

8.3 移到云上 155

8.3.1 不可变基础设施 156

8.3.2 DevOps 156

8.4 小结 157

第9章 对遗留软件的开发、构建以及部署过程进行现代化 158

9.1 开发、构建以及部署遗留软件的困难 158　　

9.1.1 缺乏自动化 158

9.1.2 过时的工具 160

9.2 更新工具链 160

9.3 用Jenkins实现持续集成与自动化 163

9.4 自动发布和部署 165

9.5 小结 172

0章 停止编写遗留代码 173

10.1 源代码并不是项目的 173

10.2 信息不能是自由的 174

10.2.1 文档 174

10.2.2 促进沟通 175

10.3 工作是做不完的 176

10.3.1 定期进行代码评审 176

10.3.2 修复一扇窗户 176

10.4 自动化一切 177

10.5 小型为佳 178

10.6 小结 180


遗留系统的现代化改造--软件技术、工程过程和业务实践 
《[二手旧书9成新] 遗留系统的现代化改造--软件技术、工程过程和业务实践 [美]塞克德,[美]普拉考士,[美]刘易斯,梁海华 9787302077107》 【简介_书评_在线阅读】 - 当当 - 天诚二手旧书专营店.html

罗伯特·C.塞克德，软件工程研究所（SEI）的高级技术人员，目前引领着一个团队专门从事软件维持方面的研究工作。他是《用商业组件构建系统》一书的著者之一。
目　　录
第1章 遗留系统危机
1.1 现代化改造面临的挑战
1.2 我们怎样到达这里
1.3 遗留系统危机
1.4 演化遗留系统
1.5 软件再工程
1.6 增量开发和部署
1.7 小结
1.8 更多阅读材料
第2章 野兽
2.1 零售供应系统
2.2 最近的历史
2.3 小结
第3章 风险管理的现代化改造 
3.1 风险管理
3.2 小结
第4章 开发业务案例
4.1 现在我们在哪里
4.2 确定涉众
4.3 理解需求
4.4 RSS需求
4.5 创建一个业务案例
4.6 RSS业务案例
4.7 小结
4.8 更多阅读材料
第5章 理解遗留系统
5.1 现在我们在哪里
5.2 程序理解的上下文：马蹄铁模型
5.3 重构
5.4 构架重构
5.5 问题
5.6 小结
5.7 更多阅读材料
第6章 构架表示
6.1 现在我们在哪里
6.2 构架表示的目的
6.3 构架表示需求
6.4 构架视图
6.5 额外的考虑
6.6 小结
6.7 更多阅读材料
第7章 语言和数据管理
7.1 现在我们在哪里
7.2 COBOL
7.3 Java
7.4 数据存储库
7.5 信息交换的数据表示
7.6 小结
第8章 事务技术
8.1 现在我们在哪里
8.2 分布式通信
8.3 事务
8.4 分布式事务操作
8.5 事务模型的比较
8.6 标准
8.7 产品
8.8 小结
第9章 软件基础结构 
9.1 现在我们在哪里
9.2 企业JavaBean
9.3 面向消息的中间件
9.4 Java2企业版
9.5 XML消息接发
9.6 小结
第10章 维护事务上下文
10.1 现在我们在哪里 
10.2 模型问题：零售供应系统
10.3 应急计划
10.4 模型问题的定义
10.5 模型问题的解决方案
10.6 评估
10.7 小结
第11章 业务对象集成 
11.1 现在我们在哪里
11.2 两个构架
11.3 质量属性
11.4 小结
第12章 目标构架 
12.1 现在我们在哪里
12.2 影响构架的力量
12.3 构架概观
12.4 构架模式
12.5 小结
第13章 构架转化
13.1 现在我们在哪里
13.2 数据适配器
13.3 逻辑适配器
13.4 构架转化策略
13.5 组件化跟踪图
13.6 RSS中适配器的使用
13.7 小结
第14章 系统准备
14.1 现在我们在哪里
14.2 选择方案的分析
14.3 小结
第15章 代码和数据迁移
15.1 现在我们在哪里
15.2 结构化分析
15.3 代码迁移计划
15.4 数据迁移计划
15.5 小结
第16章 集成计划
16.1 现在我们在哪里
16.2 协调目标
16.3 协调计划
16.4 涉众优先级
16.5 涉从理想配置
16.6 涉众共识会议
16.7 代码迁移优先级划公结果
16.8 小结
第17章 资源估计
17.1 现在我们在哪里
17.2 成本估计概述
17.3 计算一个增量的成本
17.4 成本和持续时间的估计
17.5 计算准备工作的成本
17.6 计算最后的数据库迁移的成本
17.7 数据收集
17.8 小结
17.9 更多阅读材料
第18章 建议
18.1 寻长一种更好的方式
18.2 使用商业组件
18.3 管理复杂性
18.4 增量地开发和部署
18.5 软件工程技巧
18.6 以组件为中心的方法
18.7 以构架为中心的方法
18.8 高级并行开发
18.9 持续集成
18.10 风险管理的开发
18.11 写在最后的话
参考文献
缩略语表

