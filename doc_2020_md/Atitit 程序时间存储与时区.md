Atitit 程序时间存储与时区



唐霜的博客
码
物
声
书
杂
关于
 
PHP中关于时间（戳）、时区、本地时间、UTC时间等的梳理
在PHP开发中，我们经常会在时间问题上被搞糊涂，比如我们希望显示一个北京时间，但是当我们使用date函数进行输出时，却发现少了8个小时。几乎所有的php猿类都必须对php中几个重要的时间转换等方法进行研究。本文就来梳理这些问题。
时间戳（timestamp）
GMT
在时间戳这个点上，它是一个概念，而不是具体的编程问题，是计算机世界通用的一种约定。时间戳是指格林尼治时间（GMT）1970年01月01日00时00分00秒到当前时间的总秒数。
GMT（也被称为世界时）是固定为本初子午线经过地区的时间，因此被作为时间参照物。
UTC
协调世界时（UTC）和GMT一样都是一种时间的参照物，但是他们的计算方法不同UTC是以原子时秒长为基础，在时刻上尽量接近于世界时的一种时间计量系统，从精度上讲，更加精确（自然也比GMT更精确），因此被称世界统一时间，世界标准时间，国际协调时间。
Unix时间戳
Unix时间戳是在计算机领域才有的，每一台电脑（服务器）在生产的时候，将GMT/UTC的1970年01月01日00时00分00秒作为起始值进行计算，得到的总秒数就是这个Unix时间戳。至于是GMT还是UTC意义并不大，因为GMT和UTC的1970年01月01日00时00分00秒是一致的，起点一致的情况下，运行的秒数也是一致的。
为什么要时间戳？因为从0开始运行的秒数永远相等，即使出现润秒，也并不影响时间戳。
在php中，可以通过time函数获取时间戳：
time();
但是你应该明白，time()获取的是，当前这台电脑（服务器）上的Unix时间戳。两台电脑可能这个时间戳并不相同，有的甚至相差几十秒。从理论上讲时间戳应该是一摸一样的，但是由于不同的电脑硬件出厂时的设定不同，也会导致GMT/UTC起始值稍有差异，甚至在计算每一秒时也有可能存在差异，这台机器上一秒的时间比另一台要长也是有可能的，时间久了，积累下来的时间差就会体现出来。但是，这种时间差一般不会超过几秒钟。
时区（Time Zone）
但是上面的time()的表述并不准确，因为我们在实践中经常遇到time()得到的值并不是我们想要的。对应的是，date()函数得到的值，也可能出乎我们意料。
什么是时区呢？也就是以GMT/UTC为参照物的时间偏移。
以GMT为参照物的时区
在传统的教材里，全球被划分为24个时区，首先基于经度，其次按照国家或地区，将每一个地区划分到某一个时区，这样可以避免时间上的混乱。在24时区划分之前，世界上的时间换算并没有准确的参照，比如中国人去英国，只能问当地人现在几点，然后拨自己的表来对。而当时区划分之后，中国人到了英国，只需要拨慢8小时即可。在时区划分之前，英国人跟中国人的时间可能并不是严格的8小时之差。
但为了照顾到同一个国家内时间的统一，大部分国家规定自己属于同一个时区，比如中国，统一规定为东八区，这样中国东部和西部可以采用同一个时间。毕竟没有必要大家一定要在早上6点看到日出，沿海城市5点看，乌鲁木齐9点看，并不影响大家的正常作息。
在php中，提供了大量的地区作为时区切换的标准，例如：
date_default_timezone_set('Asia/Shanghai');echo date('Y-m-d H:i:s'); // 获得的是上海所在时区的时间
注意：PRC是中国的地区时标志，并不在Asia中，而是在Others里面找。
以UTC为参照物计算时区
但随着UTC取代GMT成为世界标准时后，时区的计算开始使用UTC作为标准。UTC+8代表东八区，UTC-11代表西十一区。
不过随着精度需求的提升，按大时区计算已经不能满足需求，0.5个时区也被普遍使用，比如UTC+7.5。
在PHP中，我们可以采用这种方式来切换时区。比如：
date_default_timezone_set('UTC');echo date('Y-m-d H:i:s'); // 获取的是0时区时间
时区给PHP带来的影响
我们上面给出的代码并没有什么实际意义，因为你还不知道为什么要这样去做。实际上，php在使用date函数的时候，会依照所在时区去进行计算。
例如，你的服务器是放在英国的，而服务器的默认配置php.ini中没有规定时区，那么php就会以操作系统默认是时区作为时区进行输出，这就会导致这台服务器上的date()函数输出的时间是以UTC+0作为时区的，如果你的用户在中国，那么网站的访客看到的时间就会少8个小时。
而上面使用date()进行输出的时间，就是我们所说的本地时间。
本地时间，其实是指服务器上的程序输出时间，date函数输出的时间依托Unix时间戳和时区，因此它一定是一个不准确的时间，因为Unix时间戳基本上都是不准确的，但是这个不准确是可以忽略的，严重的是时区的偏差。
造成php输出时间混乱的原因总结起来：
使用默认的date函数的输出值
在保存时间的时候使用调整过时区的时间，而输出时又调整了时区
第一点比较容易理解，比如默认存进去的时候存入的是time()，输出的时候使用date()，time()是没有错的，但是date()在输出的时候，时区和当前访客的时区对不上，从而导致输出内容的错误。
如何在PHP中保证输出时间的准确性？
我们想的更多的是如何保证时间的准确性问题。这要从多方面去考虑，输入输出的一致性与非一致性是一个很大的挑战，你需要把握好全局关系。
1.php.ini配置文件中规定时区
从php5.1.0开始，php.ini配置文件中支持设置一个date.timezome的值来规定默认的时区，找到它，并改为：
date.timezone = PRC
当然，PRC也可以用php官方给出的列表中的其他时区代表值表示。
这种配置的好处是，可以在所有的php代码中生效，坏处是灵活性差，而且大部分主机并不直接支持php.ini配置。
2. ini_set('date.timezone')
在php代码开头，可以使用ini_set函数来临时修改一些php的默认配置，可以：
ini_set('date.timezone','Asia/Shanghai');
这种方法的好处是比较灵活，需要配置时区的代码里才使用，把这个配置放置在一个共享文件里，可以使所有引用这个文件的php脚本都获得这个配置。坏处是有的主机不支持ini_set。
3.date_default_timezone_set
和ini_set函数一样，date_default_timezone_set函数也可以临时修改php配置。
date_default_timezone_set('Asia/Shanghai');
4.自己计算
当你在输出日期的时候，可以考虑自己调整时区，然后进行计算，将计算的结果格式化为日期再输出。首先，我们要搞清楚哪些是可变哪些是不可变。
可变：date()不可变：time()、gmdate()
当你在输出一个日期的时候，如果使用date，就是可变的，但如果使用gmdate()就是不可变的，gmdate()永远把时区当做是UTC+0，即使你通过前面三种方法临时修改了时区，也不会影响gmdate的输出结果，而这个时候，其实你又知道你的访客所在的时区，所以，你可以自己计算一下：
// 方法1date('Y-m-d H:i:s',strtotime(gmdate('Y-m-d H:i:s').' +8 hours'));// 方法2（推荐）gmdate('Y-m-d H:i:s',time() + 8*3600);
使用上面的两个方法，无论你的服务器处于什么时区，无论你是否使用date_default_timezone_set设置了新的临时时区，都不会影响结果，因为gmdate永远以UTC+0作为参照，根本不会理会你新设置的时区。甚至，你把你的这段代码，从非洲的服务器搬到中国的服务器上，它的结果也还是一样（忽略timestamp的微小误差）。
有一个有趣的现象是，我们可以通过一个动态的数字来控制date()是时区，而无需去设置时区，比如：
date('Y-m-d H:i:s',time() + n*3600)
其中的n则是时区，东八区就是+8，西五区就是-5。而我们却可以找出这个动态的n值，它和时区时时相关：date('Z')
date('Z')是一个军事级别的应用，它用于计算以秒为单位的时区偏移量，比如东八区，它的值就是8*3600，我们可以在time()的基础上减去这个值，得到一个比当前时间戳少时区偏移量的值，这个值在实际中没有任何意义，它不代表任何时间戳（或者说是当前时间n小时之前的时间戳），但如果我们再对这个时间戳进行date运算时，date会把n时区的偏移量加回来，这样就得到了一个固定的UTC+0的日期时间：
$gmt_date = date('Y-m-d H:i:s',time() - date('Z'));
它的效果其实和gmdate('Y-m-d H:i:s')相同，但算法上更加复杂。
同样的道理，我们以UTC+0作为基准，增加这个偏移量，反而可以得到我们想要的时区所在的时间：
$local_time = gmdate('Y-m-d H:i:s',time() + date('Z'));
但这和$local_time = date('Y-m-d H:i:s');没有任何结果上的区别。
选择你合适的时间进行保存
在前面的分析里面，你看到有一种情况比较乱，就是使用了调整时区后的时间进行保存，但是显示的时候，又进行时区调整，这导致显示错误。
推荐的一种时间保存方案，是只保存timestamp，也就是time()，它的值是固定的，不随着时区的调整而改变，即使更换了服务器，它的误差也很小，所以有利于今后将程序分发部署到不同的服务器上面。
而在自己显示的时候，可以确定一个方法，比如上面推荐的方法2作为输出：
function st_date($format,$timestamp = false) {
  $timestamp = is_numeric($timestamp) ? $timestamp : time();
  return gmdate($format,$timestamp + 8*3600);
}
这样就可以保证这段代码无论在哪里，都可以输出东八区的时间。
 2016-10-04  28243  date, gmdate, time, timestamp
为价值买单

本文价值282.43RMB
已有12条评论



panyi 2019-08-22 01:52

最后的is_numberic是否写错了，应该是is_numeric吗？

回复




否子戈 2019-08-22 12:54

谢谢指出，已更正

回复




404 not found 2019-03-22 09:45

谢谢这个gmdate(‘Y-m-d H:i:s’,time() + 8*3600);帮了大忙

回复




PHP(一)基础语法 « 2017-10-01 17:47

[…] PHP 手册 陈惠贞 , 陈俊荣.PHP 7&MySQL跨设备网站开发[M].北京:清华大学出版社,2017 PHP 教程 PHP 教程 PHP中变量的作用范围 PHP中关于时间（戳）、时区、本地时间、UTC时间等的梳理 […]

回复




gzswar 2017-05-31 01:51

最近又研究了一下关于php里时间的转换问题。发现博主的文章有一点没有重点研究，就是关于冬令时和夏令时的问题。有些地区冬夏或者夏冬交替的时候会提前或推后一小时。按我个人的理解，date()函数应该是可以处理这个问题的，但是用gmdate()函数的话是不是就稍显麻烦了呢。希望有时间能探讨下这个问题。

回复




否子戈 2017-06-01 13:28

很久没有写php了，确实很多细节都需要慢慢研究，如果你有了答案，希望可以告诉我

回复




gzswar 2017-02-24 06:36

你好，谢谢你的这篇文章。写的十分详尽清晰，帮我彻底理解了php中时间日期函数之间与时区之间的关系。我注意的你的网站的模板很酷，能问一下是你自己写的还是在什么地方找的吗？能分享一下这套模板给我吗，或者我在哪里可以买得到呢？

回复




否子戈 2017-02-24 09:21

自己写的，不提供下载，谢谢关注^_^

回复




pookpal 2017-03-13 15:03

博主全能，非常佩服，可以仿一下用来搭建自己的博客站吗

回复




否子戈 2017-03-13 16:19

可以，不过最好写篇博文说明一下~

回复




pookpal 2017-03-13 16:21

恩，非常感谢，这个是wp的，我打算用node写一个，向博主学习，始终保持前进的好奇心




否子戈 2017-03-14 13:49

建好通知一声，我也学习下

窗体顶端
昵称 * 
邮箱 * 
网站 
验证码 

提交
窗体底端

© 2010-2019 唐霜. All rights reserved.
本站内容均为原创，未经许可，不允许转载。
蜀ICP备19035252号-1
声明
版权声明
关于
给我留言
友情链接
联系方式
友情链接
Lzane Li
安正超
林松正
腾讯CDC
超能小紫

扫码加我微信
窗体顶端

窗体底端
点击搜索按钮关闭搜索界面

