


解决方案
先判断是否在缓存中即可
涉及到序列化和对象创建工具的开发，那么需要考虑循环引用问题的解决，主要方法即将循环引用中的其中一个对象缓存起来，以避免重复地序列化或创建

使用延迟导入(lazy import)

解决循环应用解法2：使用延迟导入(lazy import)
在需要用的函数内部导入，或是在底部导入

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:05 pm]
为了解决循环引用带来的上述问题，本质上需要将循环引用中的其中一个对象缓存起来，以避免重复地序列化或创建。具体案例如下

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:05 pm]
这里采用的方式是一样的，每次序列化前先判断是否在缓存中即可

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:05 pm]
Spring是自动创建对象场景的典型，它采用三级缓存的方式解决循环引用对象的创建。

一级缓存：已经完全创建好的对象的缓存；

二级缓存：正在创建中，某些成员还未装载的对象的缓存；

三级缓存：存放创建对象方法的缓存(即存放工厂，而非对象的缓存)。

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:06 pm]
涉及到序列化和对象创建工具的开发，那么需要考虑循环引用问题的解决，主要方法即将循环引用中的其中一个对象缓存起来，以避免重复地序列化或创建

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:12 pm]
4.2 方法二: 使用@Lazy
这里有一个简单的方法来打破这种循环，就是告诉Spring 在加载context之后再初始化Beans，而不是完全初

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:12 pm]
创建一个代理bean注入到其他bean中，这种注入只有在bean第一次调用时才会被完全生效

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:13 pm]
引用计数算法（Reference Counter）
接下来我们说说，具体怎么去实现 GC。实现 GC 最简单的方案叫作引用计数，下图中节点的引用计数是 2，代表有两个节点都引用了它

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:14 pm]
Root Tracing 算法
下面我再给你介绍一种更好的方式—— Root Tracing 算法。这是一类算法，后面我们会讲解的标记-清除算法和 3 色标记-清除算法都属于这一类。

Root Tracing 的
原理是：从引用路径上，如果一个对象的引用链中包括一个根对象（Root Object），那么这个对象就是活动的。根对象是所有引用

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:14 pm]
以引用到这个对象，那么这个节点就不需要被回收。所以算法的本质还是引用，只不过判断条件从引用计数变成了有根对象的引用链。

如果一个对象从根对象不可达，那么这个对象就应该被回收，即便这个对象存在循环引用。可以看到，上图中红色的 3 个对象循环引用，并且到根集合没有引用链，因此需要被回收。这样就解决了循环引用的问题。

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:15 pm]
循环引用：
引用计数是一种便利的内存管理机制，但它有一个很大的缺点，那就是不能管理循环引用的对象。一个简单的例子如下

十 jarkas 大鱼 刘洋 汤姆, [19/08/2023 5:17 pm]
生成代理对象产生的循环依赖
这类循环依赖问题解决方法很多，主要有：

使用@Lazy注解，延迟加载
使用@DependsOn注解，指定加载先后关系
修改文件名称，改变循环依赖类的加载顺序

Ati lib sdk,Code sampl
autoloadx.php
Iniautoload.php
