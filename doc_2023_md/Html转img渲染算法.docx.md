Html转img渲染


十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:28]
别是：

解析 HTML，生成 DOM 树
解析 CSS，生成 CSS 规则集合
生成 Style 树
生成布局树
绘制使用gd库

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:28]
构建样式树
本阶段的目标是写一个样式构建器，输入 DOM 树和 CSS 规则集合，生成一棵样式树 Style tree。

v2-266e8e94510504d11b930612229012ac_1440w
样式树的每一个节点都包含了 CSS 属性值以及它对应的 DOM 节点引用

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:29]
布局树
第四阶段讲的是如何将样式树转化为布局树，也是整个渲染引擎相对比较复杂的部分。

v2-266e8e94510504d11b930612229012ac_1440w
CSS 盒子模型
在 CSS 中，所有的 DOM 节点都可以当作一个盒子。这个盒子模型包含了内容、内边距、边框、外边距以及在页面中的位置信息。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:29]
块布局和内联布局
CSS 的 display 属性决定了盒子在页面中的布局方式。display 的类型有很多种，例如 block、inline、flex 等等，但这里只支持 block 和 inline 两种布局方式，并且所有盒子的默认布局方式为 display: inline。

我会用伪 HTML 代码来

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:30]
如果容器内同时存在块布局和内联布局，则会用一个匿名布局将内联布局包裹起来。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:33]
这样就能将内联布局的盒子和其他块布局的盒子区别开来。

通常情况下内容是垂直增长的。也就是说，在容器中添加子节点通常会使容器更高，而不是更宽。另一种说法是，默认情况下，子节点的宽度取决于其容器的宽度，而容器的高度取决于其子节点的高度。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:34]
果 DOM 节点 display 属性的值为 none，则在构建布局树的过程中，无需将这个 DOM 节点添加到布局树上，直接忽略它就可以了。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:34]
如果一个块节点包含一个内联子节点，则需要创建一个匿名块（实际上就是块节点）来包含它。如果一行中有多个子节点，则将它们全部放在同一个匿名容器中。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:34]
遍历布局树
现在开始构建布局树，入口函数是 getLayoutTree()

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:35]
节内容的开头有提到过，盒子的宽度取决于其父节点，而高度取决于子节点。这意味着，我们的代码在计算宽度时需要自上而下遍历树，这样它就可以在知道父节点的宽度后设置子节点的宽度。然后自下而上遍历以计算高度，这样父节点的高度就可以在计算子节点的相关信息后进行计算。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:36]
计算宽度
现在，我们先来计算盒子节点的宽度，这部分比较复杂，需要详细的讲解。

首先，我们要拿到当前节点的 width padding border margin 等信息

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:37]
果这些属性没有设置，就使用 0 作为默认值。拿到当前节点的总宽度后，还需要和父节点对比一下是否相等。如果宽度或边距设置为 auto，则可以对这两个属性进行适当展开或收缩以适应可用空间。所以现在需要对当前节点的宽度进行检查

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:39]
通过对比当前节点和父节点的宽度，我们可以拿到一个差值：

// 根据父子元素宽度的差值，去调整当前元素的宽度
const underflow = parentWidth - totalWidth
如果这个差值为正数，说明子节点宽度小于父节点；如果差值为负数，说明子节点大于父节。上面这段代码逻辑其实就是根据 underflow width padding margin 等值对子节点的宽度、边距进行调整，以适应父节点的宽度。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:39]
定位
计算当前节点的位置相对来说简单一点。这个方法会根据当前节点的 margin border padding 样式以及父节点的位置信息对当前节点进行定位

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:40]
比如获取当前节点内容区域的 x 坐标，计算方式如下：

dimensions.content.x = x + dimensions.margin.left + dimensions.border.left + dimensions.padding.left

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:41]
遍历子节点
在计算高度之前，需要先遍历子节点，因为父节点的高度需要根据它下面子节点的高度进行适配。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:41]
每个节点的高度就是它上下两个外边距之间的差值，所以可以通过 marginBox() 获得高度：

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:41]
遍历子节点并执行完相关计算方法后，再将各个子节点的高度进行相加，得到父节点的高度。

height 属性
默认情况下，节点的高度等于其内容的高度。但如果手动设置了 height 属性，则需要将节点的高度设为指定的高度：

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:42]
小结
布局树是渲染引擎最复杂的部分，这一阶段结束后，我们就了解了布局树中每个盒子节点在页面中的具体位置和尺寸信息。下一步，就是如何把布局树渲染到页面上了。

绘制
绘制阶段主要是根据布局树中各个节点的位置、尺寸信息将它们绘制到页面。目前大多数计算机使用光栅（raster，也称为位图）显示技术。将布局树各个节点绘制到页面的这个过程也被称为“光栅化”

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:44]
浏览器通常在图形API和库（如Skia、Cairo、Direct2D等）的帮助下实现光栅化。这些API提供绘制多边形、直线、曲线、渐变和文本的功能。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:46]
绘制布局树
科普完关于绘制屏幕的基础知识后，我们现在正式开始绘制布局树（为了方便，我们使用 node-canvas 库）。

首先要遍历整个布局树，然后逐个节点进行绘制：

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:46]
过 canvas 的 fillText() 方法，我们可以很方便的绘制带有字体风格、大小、颜色的

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:46]
canvas就是php的gd库

