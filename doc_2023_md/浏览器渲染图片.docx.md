浏览器渲染图片


十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:19]
hitk  gd 图像处理 分解 合成 ocr僧

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:19]
音视频处理

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:28]
别是：

解析 HTML，生成 DOM 树
解析 CSS，生成 CSS 规则集合
生成 Style 树
生成布局树
绘制

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:28]
构建样式树
本阶段的目标是写一个样式构建器，输入 DOM 树和 CSS 规则集合，生成一棵样式树 Style tree。

v2-266e8e94510504d11b930612229012ac_1440w
样式树的每一个节点都包含了 CSS 属性值以及它对应的 DOM 节点引用

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:29]
布局树
第四阶段讲的是如何将样式树转化为布局树，也是整个渲染引擎相对比较复杂的部分。

v2-266e8e94510504d11b930612229012ac_1440w
CSS 盒子模型
在 CSS 中，所有的 DOM 节点都可以当作一个盒子。这个盒子模型包含了内容、内边距、边框、外边距以及在页面中的位置信息。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:29]
块布局和内联布局
CSS 的 display 属性决定了盒子在页面中的布局方式。display 的类型有很多种，例如 block、inline、flex 等等，但这里只支持 block 和 inline 两种布局方式，并且所有盒子的默认布局方式为 display: inline。

我会用伪 HTML 代码来

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:30]
如果容器内同时存在块布局和内联布局，则会用一个匿名布局将内联布局包裹起来。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:33]
这样就能将内联布局的盒子和其他块布局的盒子区别开来。

通常情况下内容是垂直增长的。也就是说，在容器中添加子节点通常会使容器更高，而不是更宽。另一种说法是，默认情况下，子节点的宽度取决于其容器的宽度，而容器的高度取决于其子节点的高度。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:34]
果 DOM 节点 display 属性的值为 none，则在构建布局树的过程中，无需将这个 DOM 节点添加到布局树上，直接忽略它就可以了。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:34]
如果一个块节点包含一个内联子节点，则需要创建一个匿名块（实际上就是块节点）来包含它。如果一行中有多个子节点，则将它们全部放在同一个匿名容器中。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:34]
遍历布局树
现在开始构建布局树，入口函数是 getLayoutTree()

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:35]
节内容的开头有提到过，盒子的宽度取决于其父节点，而高度取决于子节点。这意味着，我们的代码在计算宽度时需要自上而下遍历树，这样它就可以在知道父节点的宽度后设置子节点的宽度。然后自下而上遍历以计算高度，这样父节点的高度就可以在计算子节点的相关信息后进行计算。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:36]
计算宽度
现在，我们先来计算盒子节点的宽度，这部分比较复杂，需要详细的讲解。

首先，我们要拿到当前节点的 width padding border margin 等信息

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:37]
果这些属性没有设置，就使用 0 作为默认值。拿到当前节点的总宽度后，还需要和父节点对比一下是否相等。如果宽度或边距设置为 auto，则可以对这两个属性进行适当展开或收缩以适应可用空间。所以现在需要对当前节点的宽度进行检查

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:39]
通过对比当前节点和父节点的宽度，我们可以拿到一个差值：

// 根据父子元素宽度的差值，去调整当前元素的宽度
const underflow = parentWidth - totalWidth
如果这个差值为正数，说明子节点宽度小于父节点；如果差值为负数，说明子节点大于父节。上面这段代码逻辑其实就是根据 underflow width padding margin 等值对子节点的宽度、边距进行调整，以适应父节点的宽度。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:39]
定位
计算当前节点的位置相对来说简单一点。这个方法会根据当前节点的 margin border padding 样式以及父节点的位置信息对当前节点进行定位

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:40]
比如获取当前节点内容区域的 x 坐标，计算方式如下：

dimensions.content.x = x + dimensions.margin.left + dimensions.border.left + dimensions.padding.left

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:41]
遍历子节点
在计算高度之前，需要先遍历子节点，因为父节点的高度需要根据它下面子节点的高度进行适配。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:41]
每个节点的高度就是它上下两个外边距之间的差值，所以可以通过 marginBox() 获得高度：

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:41]
遍历子节点并执行完相关计算方法后，再将各个子节点的高度进行相加，得到父节点的高度。

height 属性
默认情况下，节点的高度等于其内容的高度。但如果手动设置了 height 属性，则需要将节点的高度设为指定的高度：

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:42]
小结
布局树是渲染引擎最复杂的部分，这一阶段结束后，我们就了解了布局树中每个盒子节点在页面中的具体位置和尺寸信息。下一步，就是如何把布局树渲染到页面上了。

绘制
绘制阶段主要是根据布局树中各个节点的位置、尺寸信息将它们绘制到页面。目前大多数计算机使用光栅（raster，也称为位图）显示技术。将布局树各个节点绘制到页面的这个过程也被称为“光栅化”

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:44]
浏览器通常在图形API和库（如Skia、Cairo、Direct2D等）的帮助下实现光栅化。这些API提供绘制多边形、直线、曲线、渐变和文本的功能。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:46]
绘制布局树
科普完关于绘制屏幕的基础知识后，我们现在正式开始绘制布局树（为了方便，我们使用 node-canvas 库）。

首先要遍历整个布局树，然后逐个节点进行绘制：

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:46]
过 canvas 的 fillText() 方法，我们可以很方便的绘制带有字体风格、大小、颜色的

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:46]
canvas就是php的gd库

dim IT信息技术大师imtg, [14/12/2023 下午 9:10]
步骤1：使用第三方库将HTML代码渲染为图片
在Java中，我们可以使用第三方库JSoup结合Flying Saucer将HTML代码渲染为图片。下面是使用这两个库实现的代码示例

dim IT信息技术大师imtg, [14/12/2023 下午 9:10]
述代码中，Jsoup用于解析HTML代码，Java2DRenderer用于将解析后的HTML渲染为Java 2D图像对象BufferedImage。其中，html参数为需要转化的HTML代码，outputStream参数为输出流，可以通过该流将渲染后的图片保存到本地或者输出给用户

dim IT信息技术大师imtg, [14/12/2023 下午 9:11]
代码中，Jsoup用于解析HTML代码，Java2DRenderer用于将解析后的HTML渲染为Java 2D图像对象BufferedImage。其中，html参数为需要转化的HTML代码，outputStream参数为输出流，可以通过该流将渲染后的图片保存到本地或者输出给用户。

步骤2：将渲染后的图片保存到本地或者输出给用户
将渲染后的图片保存到本地或者输出给用户，可以根据具体需求选择适合的方式进行操作。下面是将图片保存到本地的示例代码：

dim IT信息技术大师imtg, [14/12/2023 下午 9:11]
上述代码中，html变量为需要转化的HTML代码，outputStream用于保存图片的输出流，convertHtmlToImage方法将HTML代码转化为图片并保存到outputStream中，最后通过关闭输出流来完成保存操作。

dim IT信息技术大师imtg, [14/12/2023 下午 9:15]
import org.jsoup.nodes.Document;
import org.xhtmlrenderer.swing.Java2DRenderer;

import java.awt.*;
import java.awt.image.BufferedImage

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 下午 9:36]
浏览器渲染原理
Web 页面运行在各种各样的浏览器当中，浏览器载入、渲染页面的速度直接影响着用户体验，而页面渲染就是浏览器将 html 代码根据 CSS 定义的规则显示在浏览器窗口中的这个过程。

HTML 代码转化成 DOM
CSS 代码转化成 CSSOM（CSS Object Model）
结合 DOM 和 CSSOM，生成一棵渲染树（包含每个节点的视觉信息）
生成布局（flow），即将所有渲染树的所有节点进行平面合成
将布局绘制（paint）在屏幕上
"生成布局"（flow）和"绘制"（paint）相对更加耗时，合称为"渲染"（render）。



十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:07]
基于PHP，将html内容生成图片（PNG，JPEG等）

实现方法
1. 直接通过图形函数生成
可以直接使用PHP中自带的GD库或imagick，将文字内容转换成为图片。这在处理纯文字内容的时候是很给力的，但是对于富文本内容来说却很吃力了，很难处理好。目前开源的有painty等，可以支持p、img等几个简单的html标签

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:08]
2. html->pdf->png
该方式即首先将html内容生成pdf文档，再将pdf文档转换成为图片。

html to pdf：目前较为成熟的方案包括tcpdf，HTML2PDF等，其实HTML2PDF也是使用的tcpdf的内核;

pdf to png：可以通过imagick php扩展。

目前基于该种方式的开源代码有html to image，其原理如下图所示。

十 jarkas 大鱼 刘洋 汤姆, [14/12/2023 上午 4:09]
3. 通过截图
该种方式类似于采用浏览器的截图功能，直接将某个URL地址的内容进行截图。相对前面两种方式而言：第一，对于富文本的html内容渲染更为方便、 简单，直接生成html代码即可；第二，内容排版更为合理，不会出现pdf文档中存在的空白区域等问题；第三，对于中文的支持更为友好。
