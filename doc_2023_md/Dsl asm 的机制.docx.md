Dsl asm 的机制

5.函数调用机制
因而，在函数内部利用的寄存器，要尽量返回到函数调用前的状态。为此，我们就需要将其暂时保存在栈中，然后再在函数处理完毕之前出栈，使其返回到原来的状态。

在C语言中，函数的返回值必须通过%eax寄存器返回，这也是规定。不过，和%rbp寄存器不同的是，%eax寄存器的值不用还原到原始状态
中ret指令运行后，函数返回目的地的内存地址会自动出栈，据此，程序流程就会跳转返回到代码清单5-1的(12)(Call _AddNum的下一行)。这时，AddNum函数入口和出口处栈的状态变化，

这里出现了一个陌生指令call，这个指令是函数调用专用的指令，从程序的行为上看应该是让程序的执行流程发生跳转。前面说到了跳转指令jmp，这里是call，这两个指令都能让CPU的eip寄存器发生突然变化，然后程序就一下子跳到别的地方去了。但是这两个有区别：
很简单，jmp跳过去了就不知道怎么回来了，而通过call这种方式跳过去后，是可以通过ret指令直接回来的
一个程序免不了有很多次call，那这些eip的值都是保存到哪里的呢？
有一个地方叫做“栈(stack)”，是程序启动之前，由操作系统指定的一片内存区域，每一次函数调用后的返回地址都存放在栈里面
好了，我们到这里，就明白了函数调用大概是怎么回事了。总结起来就是：
本质上也是跳转，但是跳到目标位置之前，需要保存“现在在哪里”的这个信息，也就是eip
整个过程由一条指令call完成
后面可以用ret指令跳转回来
call指令保存eip的地方叫做栈，在内存里，ret指令执行的时候是直接取出栈中保存的eip值，并恢复回去达到返回的效果
call和ret的配合是依靠保存eip的值到栈里，返回时恢复eip实现的
esp记录着当前栈顶所在的位置，每次call和ret执行都会伴随着入栈和出栈，也就是esp会发生变化
函数调用最基本的”跳转“和”返回“就这么回事了，下回咱们继续分析”函数调用中的参数传递、返回值和状态“相关的问题。


为什么局部变量只能在定义改变量的函数内进行引用呢？
这是因为，局部变量是临时保存在寄存器和栈中的。正如之前讲的那样，函数内部利用的栈，在函数处理完毕后会恢复到初始状态，因此局部变量的值也就被销毁了，而寄存器也可能会被用于其他目的。因此，局部变量只是在函数处理运行期间临时存储在寄存器和栈上。

条件分支的实现方法同循环用的也是cmp指令和跳转指令
同循环处理的实现方法类似，使用的也是cmp指令和跳转指令，这一点估计大家也预料到了。为了加深印象我们也来看下。

用到了三种跳转指令，分别是比较结果小或相等时跳转的jle（jump on less or equal）、大或相等时跳转的jge（jump on greater orequal）、不管结果怎样都无条件跳转的jmp。在这些跳转指令之前还有用来比较的cmp指令，比较结果被保存在了标志寄存器中。这里我们添加了注释，大家不妨顺着程序的流程看一下

作者：快手电商无线团队
链接：https://juejin.cn/post/6979911017014755365
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

