为了解决命名冲突等问题，产生了一些解决的方法

IIFE函数立即执行表达式
 (Immediately Invoked Function Expression) 函数立即执行表达式 → 通过匿名函数的来解决

内部函数
命名空间
Oo


2. CommonJS模块化规范诞生  node适合cjs模式同步简单方便
注意！！！这只是一个规范！！！这不是一个语法，只是一个规范。
规范是什么意思呢？就是我给你说了一个大方向，你自己去实现。
国家给了你一个政策，各个地方都因地制宜制定不同的细则的感觉！
比如模块化的规范在NodeJS里就是CommonJS，在ES6里就是ES module。
最初提出来是在浏览器以外的地方使用，并且当时被命名为ServerJS，后来为了 体现它的广泛性，修改为CommonJS，平时我们也会简称为CJS。
既然CommonJS只是一个规范，那么NodeJS是怎么实现这种规范的呢？
模块化最重要的就是解决导入和导出！
3. CommonJS规范的缺点
CommonJS加载模块是同步的
同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行
这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快
如果将它应用于浏览器呢


CommonJS 的缺点之一是它是同步的，AMD 旨在通过规范中定义的 API 异步加载模块及其依赖项来解决这个问题。AMD 全称为 Asynchronous Module Definition，即异步模块加载机制。它规定了如何定义模块，如何对外输出，如何引入依赖。
AMD规范重要特性就是异步加载。所谓异步加载，就是指同时并发加载所依赖的模块，当所有依赖模块都加载完成之后，再执行当前模块的回调函数。这种加载方式和浏览器环境的性能需求刚好吻合。
CJS优点
CJS是同步加载 通过调用require()函数来访问module.export
在Node中 每个CJS文件都会生成一个module实例对象 导出使用的就是其中的module.export
可以支持动态加载 比如在if中加载模块
ini
复制代码
// 不同的情况加载不同的模块if(ENV==="dev"){	const fn = require('./aFun.js')}else {	const fn = require('./bFun.js')}

ESM优点
因为ESM (import)先有一个构建依赖图的过程 所以在这个过程中可以很方便的进行静态处理
构建时可以进行各种静态检查 : 静态类型检查 (比如Ts就使用ESM语法) 变量检查
构建时可以消除死代码 treeShakiing
因为构建了依赖图 可以更快的查找导入 如果是CJS 需要访问一个对象 并且进行动态属性查找 速度慢
可以更方便的支持其他语言 静态的可以进行编译
支持循环依赖 子依赖父 父依赖子 (因为是静态)
ESM缺点
不支持动态
不能像CJS一样在语句中进行引入
不能进行解构 (只是看上去像解构 真正的解构是动态访问对象) 如下:

作者：不月阳九
链接：https://juejin.cn/post/7115354696637743117
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

